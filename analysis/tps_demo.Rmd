---
title: "TPS Coordinate Mapping Demo"
subtitle: "Demonstrating thin-plate spline landmark registration for integument analysis"
author: "Tina Lasisi"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 8
)
```

## Overview

This document demonstrates **thin-plate spline (TPS) coordinate mapping** - the 
method we propose for standardizing pelage pattern measurements across individuals.

**Key concept**: TPS is a *coordinate transformation*, not image warping. Given 
homologous landmarks on two individuals, TPS computes a smooth function that maps 
any point in the source coordinate system to the corresponding location in the 
target coordinate system.

This is the same approach used by [Van Belleghem et al. (2018)](https://doi.org/10.1111/2041-210X.12853) 
in the `patternize` R package for analyzing butterfly wing patterns.

## Setup

```{r load-packages}
# Core packages
library(tidyverse)
library(jsonlite)

# TPS and geometric morphometrics
library(Morpho)      # TPS computation
library(geomorph)    # Procrustes alignment (optional)

# Image handling
library(imager)      # Reading images
library(grid)        # Plotting

# If patternize is available (has additional TPS utilities)
# library(patternize)
```

```{r paths}
# Path to OpenApePose data
data_dir <- "/nfs/turbo/lsa-tlasisi1/tlasisi/Leakey2025/data/OpenApePose"

# Annotations in COCO format
annotations_file <- file.path(data_dir, "annotations", "openapepose_train.json")
# Note: actual filename may differ - check after extraction
```

## Load Annotations

The OpenApePose dataset uses COCO format annotations with 16 landmarks:

1. Nose
2. Left eye
3. Right eye  
4. Head
5. Neck
6. Left shoulder
7. Right shoulder
8. Left elbow
9. Right elbow
10. Left wrist
11. Right wrist
12. Sacrum (hip midpoint)
13. Left knee
14. Right knee
15. Left foot
16. Right foot

```{r load-annotations, eval=FALSE}
# Load COCO annotations
coco <- fromJSON(annotations_file)

# Extract image info
images_df <- as_tibble(coco$images)

# Extract annotations (landmarks)
annotations_df <- as_tibble(coco$annotations)

# Filter for gibbons (category_id for gibbons - need to check)
# The dataset includes: chimpanzee, bonobo, gorilla, orangutan, gibbon, siamang
categories_df <- as_tibble(coco$categories)
print(categories_df)

# Find gibbon images
gibbon_cat_id <- categories_df %>% 
  filter(str_detect(tolower(name), "gibbon")) %>% 
  pull(id)

gibbon_annotations <- annotations_df %>%
  filter(category_id == gibbon_cat_id)

# Get a sample of gibbon images with good landmark visibility
# (num_keypoints indicates how many landmarks are visible)
good_gibbons <- gibbon_annotations %>%
  filter(num_keypoints >= 12) %>%  # Most landmarks visible
  slice_sample(n = 10)
```

## Extract Landmark Coordinates

```{r extract-landmarks, eval=FALSE}
# Function to parse COCO keypoints format
# COCO stores as: [x1, y1, v1, x2, y2, v2, ...] where v is visibility
parse_keypoints <- function(keypoints) {
  kp_matrix <- matrix(keypoints, ncol = 3, byrow = TRUE)
  colnames(kp_matrix) <- c("x", "y", "visibility")
  as_tibble(kp_matrix) %>%
    mutate(landmark_id = row_number())
}

# Extract landmarks for two example individuals
individual_1 <- good_gibbons %>% slice(1)
individual_2 <- good_gibbons %>% slice(2)

landmarks_1 <- parse_keypoints(individual_1$keypoints[[1]])
landmarks_2 <- parse_keypoints(individual_2$keypoints[[1]])

# Get image paths
img1_info <- images_df %>% filter(id == individual_1$image_id)
img2_info <- images_df %>% filter(id == individual_2$image_id)

img1_path <- file.path(data_dir, "images", img1_info$file_name)
img2_path <- file.path(data_dir, "images", img2_info$file_name)
```

## TPS Coordinate Mapping

Here's the key demonstration: TPS computes a **smooth mapping function** between 
two sets of homologous landmarks.

```{r tps-computation, eval=FALSE}
# Prepare landmark matrices (only visible landmarks)
# Rows = landmarks, Cols = x, y coordinates

visible_1 <- landmarks_1 %>% filter(visibility > 0)
visible_2 <- landmarks_2 %>% filter(visibility > 0)

# Find common visible landmarks
common_landmarks <- intersect(visible_1$landmark_id, visible_2$landmark_id)

lm1_matrix <- visible_1 %>%
  filter(landmark_id %in% common_landmarks) %>%
  arrange(landmark_id) %>%
  select(x, y) %>%
  as.matrix()

lm2_matrix <- visible_2 %>%
  filter(landmark_id %in% common_landmarks) %>%
  arrange(landmark_id) %>%
  select(x, y) %>%
  as.matrix()

# Compute TPS transformation: maps coordinates FROM individual 1 TO individual 2
# This gives us a function that can transform ANY point, not just the landmarks
tps_transform <- Morpho::computeTransform(
  lm2_matrix,  # target landmarks
  lm1_matrix,  # source landmarks
  type = "tps"
)
```

## Applying the Coordinate Transformation

The power of TPS is that once computed from landmarks, it can map **any point** 
from the source coordinate system to the target.

```{r apply-tps, eval=FALSE}
# Define a grid of sample points across individual 1's body region
# This simulates sampling integument traits at standardized locations

# Create a grid within the bounding box of landmarks
x_range <- range(lm1_matrix[, 1])
y_range <- range(lm1_matrix[, 2])

sample_grid <- expand_grid(
  x = seq(x_range[1], x_range[2], length.out = 20),
  y = seq(y_range[1], y_range[2], length.out = 20)
) %>%
  as.matrix()

# Apply TPS transformation to map these points to individual 2's coordinate space
mapped_points <- Morpho::applyTransform(sample_grid, tps_transform)

# Now mapped_points contains the corresponding locations on individual 2
# where we would sample to get homologous measurements
```

## Visualization

```{r four-panel-figure, eval=FALSE, fig.width=12, fig.height=10}
# Create 4-panel figure for rebuttal

par(mfrow = c(2, 2))

# Panel A: Individual 1 with landmarks
img1 <- load.image(img1_path)
plot(img1, main = "A. Source individual with landmarks")
points(lm1_matrix, pch = 19, col = "red", cex = 1.5)
text(lm1_matrix, labels = common_landmarks, pos = 3, col = "red", cex = 0.8)

# Panel B: Individual 2 with landmarks  
img2 <- load.image(img2_path)
plot(img2, main = "B. Target individual with landmarks")
points(lm2_matrix, pch = 19, col = "blue", cex = 1.5)
text(lm2_matrix, labels = common_landmarks, pos = 3, col = "blue", cex = 0.8)

# Panel C: TPS deformation grid
# Shows how the coordinate space is warped
plot(NULL, xlim = x_range, ylim = y_range, asp = 1,
     main = "C. TPS coordinate transformation",
     xlab = "x", ylab = "y")

# Draw original grid
for (i in seq(x_range[1], x_range[2], length.out = 10)) {
  lines(c(i, i), y_range, col = "gray80")
}
for (j in seq(y_range[1], y_range[2], length.out = 10)) {
  lines(x_range, c(j, j), col = "gray80")
}

# Draw transformed grid
grid_lines_x <- seq(x_range[1], x_range[2], length.out = 10)
grid_lines_y <- seq(y_range[1], y_range[2], length.out = 10)

for (i in grid_lines_x) {
  line_pts <- cbind(rep(i, 50), seq(y_range[1], y_range[2], length.out = 50))
  transformed <- Morpho::applyTransform(line_pts, tps_transform)
  lines(transformed, col = "blue", lwd = 1.5)
}
for (j in grid_lines_y) {
  line_pts <- cbind(seq(x_range[1], x_range[2], length.out = 50), rep(j, 50))
  transformed <- Morpho::applyTransform(line_pts, tps_transform)
  lines(transformed, col = "blue", lwd = 1.5)
}

points(lm1_matrix, pch = 19, col = "red", cex = 2)
points(lm2_matrix, pch = 17, col = "blue", cex = 2)
legend("topright", legend = c("Source landmarks", "Target landmarks"),
       pch = c(19, 17), col = c("red", "blue"))

# Panel D: Mapped sample points
plot(img2, main = "D. Mapped sampling locations on target")
points(mapped_points, pch = 3, col = "green", cex = 0.8)
points(lm2_matrix, pch = 19, col = "blue", cex = 1.5)
legend("topright", 
       legend = c("Landmarks", "TPS-mapped sample points"),
       pch = c(19, 3), col = c("blue", "green"))

par(mfrow = c(1, 1))
```

## Key Points for Reviewers

1. **TPS is coordinate mapping, not image manipulation**: The transformation 
   computes corresponding locations across individuals based on anatomical 
   homology defined by landmarks.

2. **Standardized sampling**: Once the TPS function is computed, we can sample 
   integument traits (color, texture, hair density) at corresponding anatomical 
   locations across all individuals.

3. **Established methodology**: This approach is widely used in geometric 
   morphometrics and has been specifically applied to pelage/integument patterns 
   in the `patternize` package (Van Belleghem et al. 2018).

4. **Not shape warping for visualization**: Unlike some applications that use 
   TPS to create "average" shapes or morph images, our use is purely for 
   establishing point correspondences to enable standardized measurement.

## Session Info

```{r session-info}
sessionInfo()
```

## References

- Van Belleghem, S. M., et al. (2018). patternize: An R package for quantifying 
  colour pattern variation. *Methods in Ecology and Evolution*, 9(2), 390-398.
  https://doi.org/10.1111/2041-210X.12853

- Bookstein, F. L. (1989). Principal warps: Thin-plate splines and the 
  decomposition of deformations. *IEEE Transactions on Pattern Analysis and 
  Machine Intelligence*, 11(6), 567-585.
